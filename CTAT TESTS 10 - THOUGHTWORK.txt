CTAT Assessment Test 10


1)Given a string, Find the 1st repeated word in a string


CODE :- 


#include<stdio.h>
#include<malloc.h>
#include<string.h>
int isThereInHash( char ** ht , char *str , int hctr)
{
int ctr;
if( hctr==0)return 0;
for( ctr=0;ctr<hctr;ctr++)
if( strcmp(ht[ctr],str) == 0) return 1;
return 0;
}
int main()
{
char str[100];// = "This is a test sentence to test";//"Ravi had been saying that Ravi had";//"he had had he";
char ** ht=NULL;
int ctr,len,hctr,safe;
scanf("%[^\n]s",str);
len=strlen(str);
for( ctr=0,safe=ctr,hctr=0;ctr<=len ; ctr++ )
{
if( str[ctr]== ' '||str[ctr]==NULL)
{
str[ctr] = '\0';
if( isThereInHash(ht,str+safe,hctr)==1 )
{
printf("%s",str+safe);break;
}
else
{
ht=(char**)realloc(ht,sizeof(char*)*(hctr+1));
ht[hctr]=(char*)malloc(strlen(str+safe)+1);
strcpy(ht[hctr],str+safe);
str[ctr]=' ';
hctr++;
safe = ctr+1;
}
}
}
if(ctr>len)printf("No Repetition");
}



2)We are given a count of songs to be played – n, highest volume allowed – h, initial volume – i, and list of allowed volume change A[] of size n. The singer can either increase/decrease the volume of sound system for the next song by the allowed volume change A[j] for jth song from the volume of the j-1th song. The aim is to maximize the volume of last sound. Find the maximum volume that can be attained,or return -1 if there is no possibility of changing volume due to the given constrains. (Volume cannot be in negative.)


CODE :- 


#include<stdio.h>
int main()
{
int initial , high , n , ind , sum;
scanf("%d" , &n);
int arr[n];
for(ind = 0 ; ind < n ; ind++)
scanf("%d" , &arr[ind]);
scanf("%d%d" ,&initial , &high);
sum = initial;
for(ind = 0 ; ind < n ; ind++)
{
sum += arr[ind];
if( sum > high)
sum = arr[ind];
if( sum == high)
break;
}
if( sum == high)
printf("%d " , 1);
else
printf("%d" , -1);

return 0 ;
}



3)Write a program to print all Subsequences of String which Start with Vowel and End with Consonant . Given a string return all possible subsequences which start with vowel and end with a consonant. A String is a subsequence of a given String, that is generated by deleting some character of a given string without changing its order.


CODE :- 


#include<stdio.h>
#include<string.h>
#include<malloc.h>
#define isVowel(ch) (strchr("aeiou" , ch) != 0 )
int count;
char** find(char * str)
{
static char **output;
char safe;
int start , end;
start = 0;
end = strlen(str) -1;

while(start != end)
{
if( !isVowel(str[end]) )
{
output = (char**)realloc(output , (count+2) * sizeof(char*));
output[count] = (char*)malloc(strlen(str) + 1);
output[count+1] = (char*)malloc(strlen(str) + 1);
safe = str[end+1];
str[end+1] = 0;
if( count==0 || strcmp(output[count-1] , str) != 0 )
strcpy(output[count++] , str );
str[end+1] = safe;
if( strlen(output[count-1]) != 2 || output[count-1][0] != str[start] && output[count-1][1] != str[end])
{
output[count][0] = str[start];
output[count][1] = str[end];
output[count][2] = 0;
count++;
}
}
end--;
}
return output;
}
int main()
{
char str[50];
char **output;
int ind;
scanf("%s" , str);
for(ind = 0 ; str[ind] ; ind++)
{
if( isVowel(str[ind]) && str[ind+1] != 0 )
output = find(str+ind);
}
for(ind = 0 ; ind < count ; ind++)
printf("%s " , output[ind]);
for(ind = 0 ; ind < count ; ind++)
free(output[ind]);
free(output);
return 0;
}

#include<stdio.h>
#include<string.h>
#include<malloc.h>
#define isVowel(ch) (strchr("aeiou" , ch) != 0 )
int count;
char** find(char * str)
{
static char **output;
char safe;
int start , end;
start = 0;
end = strlen(str) -1;
while(start != end)
{
if( !isVowel(str[end]) )
{
output = (char**)realloc(output , (count+2) * sizeof(char*));
output[count] = (char*)malloc(strlen(str) + 1);
output[count+1] = (char*)malloc(strlen(str) + 1);
safe = str[end+1];
str[end+1] = 0;
if( count==0 || strcmp(output[count-1] , str) != 0 )
strcpy(output[count++] , str );
str[end+1] = safe;
if( strlen(output[count-1]) != 2 || output[count-1][0] != str[start] && output[count-1][1] != str[end])
{
output[count][0] = str[start];
output[count][1] = str[end];
output[count][2] = 0;
count++;
}
}
end--;
}
return output;
}
int main()
{
char str[50];
char **output;
int ind;
scanf("%s" , str);
for(ind = 0 ; str[ind] ; ind++)
{
if( isVowel(str[ind]) && str[ind+1] != 0 )
output = find(str+ind);
}
for(ind = 0 ; ind < count ; ind++)
printf("%s " , output[ind]);
for(ind = 0 ; ind < count ; ind++)
free(output[ind]);
free(output);
return 0;
}


4)Let 1 represent ‘A’, 2 represents ‘B’, etc. Given a digit sequence, count the number of possible decodings of the given digit sequence.


CODE :-


#include <iostream>
#include <cstring>
using namespace std;
// Given a digit sequence of length n, returns count of possible
// decodings by replacing 1 with A, 2 woth B, ... 26 with Z
int countDecoding(char *digits, int n)
{
// base cases
if (n == 0 || n == 1)
return 1;
int count = 0; // Initialize count
// If the last digit is not 0, then last digit must add to
// the number of words
if (digits[n-1] > '0')
count = countDecoding(digits, n-1);
// If the last two digits form a number smaller than or equal to 26,
// then consider last two digits and recur
if (digits[n-2] == '1' || (digits[n-2] == '2' && digits[n-1] < '7') )
count += countDecoding(digits, n-2);
return count;
}
// Driver program to test above function
int main()
{
char digits[100] ;
cin>>digits;
int n = strlen(digits);
cout << countDecoding(digits, n);
return 0;
}



5)You are given an array of 0s and 1s in random order. Segregate 0s on left side and 1s on right side of the array. Traverse array only once.


CODE :- 


#include<stdio.h>
#include<malloc.h>
int main()
{
int *arr,n,count=0,ctr,sum=0;
scanf("%d",&n);
arr = (int*)malloc(sizeof(int)*n);
for( ctr = 0 ; ctr < n ; ctr++)
scanf("%d",&arr[ctr]);
for( ctr =0 ; ctr<n;ctr++)
sum +=arr[ctr];
if(sum > 0 && sum < n){
for(ctr=0;ctr<n-sum;ctr++)
arr[ctr]=0;
for(;ctr<n;ctr++) arr[ctr]=1;}
for( ctr = 0 ; ctr <n ; ctr++)
printf("%d ",arr[ctr]);
}